<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">






  
  
  <link rel="stylesheet" media="all" href="/lib/Han/dist/han.min.css?v=3.3">




<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">






  <meta name="keywords" content="android,2021,">










<meta name="description" content="android提供了大量的view来与用户进行交互并显示不同种类的数据，但当由特殊的需求时，内置的view也不一定能实现我们的需求，这个时候就需要我们定义自己需要的view">
<meta name="keywords" content="android,2021">
<meta property="og:type" content="article">
<meta property="og:title" content="关于安卓自定义控件">
<meta property="og:url" content="http://yoursite.com/2021/03/28/custom-view/index.html">
<meta property="og:site_name" content="Hello World">
<meta property="og:description" content="android提供了大量的view来与用户进行交互并显示不同种类的数据，但当由特殊的需求时，内置的view也不一定能实现我们的需求，这个时候就需要我们定义自己需要的view">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2021-03-30T14:03:03.792Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="关于安卓自定义控件">
<meta name="twitter:description" content="android提供了大量的view来与用户进行交互并显示不同种类的数据，但当由特殊的需求时，内置的view也不一定能实现我们的需求，这个时候就需要我们定义自己需要的view">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: "",
      labels: ""
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2021/03/28/custom-view/">





  <title>关于安卓自定义控件 | Hello World</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hello World</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/03/28/custom-view/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="tzhxh">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hello World">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">关于安卓自定义控件</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-28T10:21:45+08:00">
                2021-03-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body han-init-context" itemprop="articleBody">

      
      

      
        <p>android提供了大量的view来与用户进行交互并显示不同种类的数据，但当由特殊的需求时，内置的view也不一定能实现我们的需求，这个时候就需要我们定义自己需要的view</p>
<a id="more"></a>
<p>设计良好的类总是相似的。它使用一个好用的接口来封装一个特定的功能，它有效的使用CPU与内存，等等。为了成为一个设计良好的类，自定义的view应该:</p>
<ul>
<li>遵守Android标准规则。</li>
<li>提供自定义的风格属性值并能够被Android XML Layout所识别</li>
<li>发出可访问的事件。</li>
<li>能够兼容Android的不同平台。</li>
</ul>
<p><strong>目录</strong></p>
<ul>
<li><a href="step1">创建自定义view类</a></li>
<li><a href="step2">绘制自定义view类</a></li>
<li><a href="step3">提供交互</a></li>
<li><a href="step4">优化自定义view</a></li>
</ul>
<h3 id="step1">创建自定义view类</h3>

<h4>继承一个View</h4><br>Android提供的组件都是继承自view,自定义的view可以直接继承View,也可以通过继承一个既有的子类(例如 Button)来节约一点时间。<br><br>继承了View之后，需要提供至少一个构造器，<br><code><br>    class MyView extends View {<br>        public MyView(Context context, AttributeSet attrs) {<br>            super(context, attrs);<br>        }<br>    }<br></code><br><br><h4>自定义属性</h4><br>为了添加View到ui上，需要通过xml熟悉来指定它的样式以及行为。良好的自定义view可以通过xml添加和改变样式。<br>- 为自定义view在资源标签下定义自设的属性<br>- 在你的XML layout中指定属性值<br>- 在运行时获取属性值<br>- 把获取到的属性应用到你的view上<br><br>为了定义自设的属性，添加资源到你的项目中。放置于<em>res/values/attrs.xml</em>文件，举个例子：<br><code><br><resources><br>   <declare-styleable name="MyView"><br>       <attr name="showText" format="boolean"><br>       <attr name="labelPosition" format="enum"><br>           <enum name="left" value="0"><br>           <enum name="right" value="1"><br>       </enum></enum></attr><br>   </attr></declare-styleable><br></resources><br></code><br>上面的代码声明了两个自设属性，<strong>showText</strong>和<strong>labelPosition</strong>，他们归属于MyView的项目下的styleable实例，通常与自定义的view名字一致<br><br>当你定义了自设的属性，就可以在layout xml文件中使用他们，就像内置属性一样，唯一不同的是归属于不同的命名空间，再举个例子：<br><br><code><br><relativelayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"><br><br>        <myview android:layout_width="match_parent" android:layout_height="match_parent" app:showtext="false" app:labelposition="0"><br><br></myview></relativelayout><br></code><br><br>如上代码所示 MyView中的属性layout_width，layout_height等和自定义的属性layout_height， labelPosition属于不同命名空间<br><code><br>xmlns:android=”<a href="http://schemas.android.com/apk/res/android&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res/android&quot;</a><br>xmlns:app=”<a href="http://schemas.android.com/apk/res-auto&quot;" target="_blank" rel="noopener">http://schemas.android.com/apk/res-auto&quot;</a><br></code><br><br><h4>获取自定义属性</h4><br>再attr.xml设置了自定义属性后，我们怎么获取再layout xml中设置的属性呢？通常是使用<em>obtainStyledAttributes()</em>来获取属性值。这个方法会传递一个<em>TypedArray</em>对象<br><br><br>Android资源编译器帮我们做了许多工作来使调用<em>obtainStyledAttributes()</em>更简单，对res目录里的每一个<em><declare-styleable></declare-styleable></em>资源，自动生成的R.java文件定义了存放属性id的数组和常量，常量用来索引数组中的每个属性，我们可以用这些预先定义的常量来从<em>TypedArray</em>中读取属性：<br><code><br>    class MyView extends View {<br>        public MyView(Context context, AttributeSet attrs) {<br>            super(context, attrs);<br>             TypedArray mTypeArray = context.getTheme().obtainStyledAttributes(attrs, R.styleable.MyView, 0, 0)<br>            try {<br>                mShowText = mTypeArray.getBoolean(R.styleable.MyView_showText, false);<br>                   mTextPos = mTypeArray.getInteger(R.styleable.MyView_labelPosition, 0);<br>            } finally {<br>                   mTypeArray.recycle()<br>            }<br>        }<br>    }<br></code><br>清注意TypedArray对象是一个共享资源，必须被在使用后进行回收。<br><br><h4>添加属性和事件</h4>

<p>Attributes是一个强大的控制view的行为与外观的方法，但是他们仅仅能够在view被初始化的时候被读取到。为了提供一个动态的行为，需要暴露出一些合适的getter 与setter方法。</p>
<p>定义一些public方法，以供用户可以动态设置，如果涉及到样式变动，需要在方法中加入<em>invalidate()</em>或<em>requestLayout()</em>或两个一起。</p>
<h3 id="step2">绘制自定义view类</h3>

<p>重绘一个自定义的view的最重要的步骤是重写<em>onDraw()</em>方法。<em>onDraw()</em>的参数是一个<em>Canvas</em>对象。<em>Canvas</em>类定义了绘制文本，线条，图像与许多其他图形的方法。你可以在<em>onDraw</em>方法里面使用那些方法来创建你的UI。<br>具体的绘制会在其他笔记详细的写一下。<br>简单来说就是在<em>onDraw()</em>提供的<em>Canvas</em>中使用自己创建的<em>Paint</em>来绘制，<em>Canvas</em>是一块画布，<em>Paint</em>是一支笔。两者配合完成绘制</p>
<p>除了<em>onDraw()</em>方法之外，还有两个重要的方法<em>onMeasure()</em>以及<em>onLayout()</em>。</p>
<p>在这里主要还是讲一下<a href="#onMeasure">onMeasure()</a>和<a href="#onLayout">onLayout()</a>吧</p>
<p>首先从整体看</p>
<ul>
<li><p>测量流程：从根 View 递归调用每一级子 View 的 measure 方法，对它们进行测量。</p>
</li>
<li><p>布局流程：从根 View 递归调用每一级子 View 的 layout 方法，把测量过程得出的子 View 的位置和尺寸传给子 View，子 View 保存。</p>
</li>
</ul>
<h4 id="onMeasure">onMeasure()</h4>

<p><code><br>    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {<br>        super.onMeasure(widthMeasureSpec, heightMeasureSpec)<br>    }<br></code><br>如上所示，<em>onMeasure()</em>有两个参数。参数即父类传过来的两个宽高的”建议值”，即把当前view的高设置为：<em>heightMeasureSpec</em> ;宽设置为：<em>widthMeasureSpec</em></p>
<p>这个参数不是简单的整数类型，而是2位整数(模式类型)和30位整数(实际数值) 的组合</p>
<ul>
<li><p>UNSPECIFIED(未指定)，父元素部队自元素施加任何束缚，子元素可以得到任意想要的大小；UNSPECIFIED=00000000000000000000000000000000</p>
</li>
<li><p>EXACTLY(完全)，父元素决定自元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；EXACTLY =01000000000000000000000000000000</p>
</li>
<li><p>AT_MOST(至多)，子元素至多达到指定大小的值。 他们对应的二进制值分别是： AT_MOST =10000000000000000000000000000000 </p>
</li>
</ul>
<p>最前面两位代表模式，分别对应十进制的0，1，2；</p>
<p>获取模式int值 和 获取数值int值的方法：<br>1 <em>int measureWidth = MeasureSpec.getSize(widthMeasureSpec);</em><br>2 <em>int measureHeight = MeasureSpec.getSize(heightMeasureSpec);</em><br>3 <em>int measureWidthMode = MeasureSpec.getMode(widthMeasureSpec);</em><br>4 <em>int measureHeightMode = MeasureSpec.getMode(heightMeasureSpec);</em></p>
<p>模式的值有:</p>
<ul>
<li>MeasureSpec.AT_MOST       = 2  = wrap_content</li>
<li>MeasureSpec.EXACTLY       = 1  = match_parent</li>
<li>MeasureSpec.UNSPECIFIED   = 0  = 具体值</li>
</ul>
<p>当为match_parent或者用户设置的具体值时，我们可以不用理会，但是当wrap_content时，我们需要设置一个数值，否则就会造成wrap_content和match_parent是一样的效果</p>
<p>使用<em>setMeasuredDimension(int measuredWidth, int measuredHeight);</em>方法，将你要设的大小设置进去</p>
<p></p><h4 id="onLayout">onLayout()</h4><br><code><br>    override fun onLayout(changed: Boolean, l: Int, t: Int, r: Int, b: Int) {<br>        super.onLayout(changed, l, t, r, b)<br>    }<br></code><br>如上代码所示，该方法中的后四个参数代表了4条边的位置，我们可以通过设置四条边来确定摆放的位置。<p></p>
<h3 id="step3">提供交互</h3>

<blockquote>
<p>绘制UI仅仅是创建自定义View的一部分。你还需要使得你的View能够以模拟现实世界的方式来进行反馈。对象应该总是与现实情景能够保持一致。例如，图片不应该突然消失又从另外一个地方出现，因为在现实世界里面不会发生那样的事情。正确的应该是，图片从一个地方移动到另外一个地方。</p>
</blockquote>
<blockquote>
<p>用户应该可以感受到UI上的微小变化，并对模仿现实世界的细微之处反应强烈。例如，当用户fling(迅速滑动)一个对象时，应该在开始时感到摩擦带来的阻力，在结束时感到fling带动的动力。应该在滑动开始与结束的时候给用户一定的反馈。</p>
</blockquote>
<p>像许多其他UI框架一样，Android提供一个输入事件模型。用户的动作会转换成触发一些回调函数的事件，你可以重写这些回调方法来定制你的程序应该如何响应用户的输入事件。在Android中最常用的输入事件是touch，它会触发<em>onTouchEvent(android.view.MotionEvent))</em>的回调。重写这个方法来处理touch事件：</p>
<p><code><br>@Override<br>public boolean onTouchEvent(MotionEvent event) {<br>  return super.onTouchEvent(event);<br>}<br></code></p>
<p>Touch事件本身并不是特别有用。如今的touch UI定义了touch事件之间的相互作用，叫做<em>gestures</em>。例如tapping,pulling,flinging与zooming。为了把那些touch的源事件转换成gestures, Android提供了<em>GestureDetector</em>。</p>
<p>通过传入<em>GestureDetector.OnGestureListener</em>的一个实例构建一个<em>GestureDetector</em>。如果你只是想要处理几种gestures(手势操作)你可以继承<em>GestureDetector.SimpleOnGestureListener</em>，而不用实现<em>GestureDetector.OnGestureListener</em>接口。例如，下面的代码创建一个继承<em>GestureDetector.SimpleOnGestureListener</em>的类，并重写<em>onDown(MotionEvent))</em>。</p>
<p><code><br>  class MyGestureDetector extends GestureDetector.SimpleOnGestureListener {<br>   @Override<br>   public boolean onDown(MotionEvent e) {<br>       return true;<br>   }<br>}</code></p>
<p>mDetector = new GestureDetector(PieChart.this.getContext(), new MyGestureDetector());<br></p>
<p>不管你是否使用<em>GestureDetector.SimpleOnGestureListener</em>, 你必须总是实现<em>onDown()</em>方法，并返回<strong>true</strong>。这一步是必须的，因为所有的<em>gestures</em>都是从<em>onDown()</em>开始的。如果你在<em>onDown()</em>里面返回false，系统会认为你想要忽略后续的<em>gesture</em>,那么<em>GestureDetector.OnGestureListener</em>的其他回调方法就不会被执行到了。</p>
<p>一旦你实现了<em>GestureDetector.OnGestureListener</em>并且创建了<em>GestureDetector</em>的实例, 你可以使用你的<em>GestureDetector</em>来中止你在<em>onTouchEvent</em>里面收到的touch事件。</p>
<p><code><br>@Override<br>public boolean onTouchEvent(MotionEvent event) {<br>   boolean result = mDetector.onTouchEvent(event);<br>   if (!result) {<br>       if (event.getAction() == MotionEvent.ACTION_UP) {<br>           stopScrolling();<br>           result = true;<br>       }<br>   }<br>   return result;<br>}<br></code></p>
<p>当你传递一个touch事件到onTouchEvent()时，若这个事件没有被辨认出是何种gesture，它会返回false。你可以执行自定义的gesture-decection代码。</p>
<p>具体内容查看<a href="http://hukai.me/android-training-course-in-chinese/ui/custom-view/make-interactive.html" target="_blank" rel="noopener">这里吧</a></p>
<h3 id="step4">优化自定义view</h3>

<p>为了避免UI显得卡顿，你必须确保动画能够保持在60fps</p>
<p>为了加速你的view，对于频繁调用的方法，需要尽量减少不必要的代码。先从onDraw开始，需要特别注意不应该在这里做内存分配的事情，因为它会导致GC，从而导致卡顿。在初始化或者动画间隙期间做分配内存的动作。不要在动画正在执行的时候做内存分配的事情。</p>
<p>你还需要尽可能的减少onDraw被调用的次数，大多数时候导致onDraw都是因为调用了invalidate().因此请尽量减少调用invaildate()的次数。如果可能的话，尽量调用含有4个参数的invalidate()方法而不是没有参数的invalidate()。没有参数的invalidate会强制重绘整个view。</p>
<p>另外一个非常耗时的操作是请求layout。任何时候执行requestLayout()，会使得Android UI系统去遍历整个View的层级来计算出每一个view的大小。如果找到有冲突的值，它会需要重新计算好几次。另外需要尽量保持View的层级是扁平化的，这样对提高效率很有帮助。</p>
<p>如果你有一个复杂的UI，你应该考虑写一个自定义的ViewGroup来执行他的layout操作。与内置的view不同，自定义的view可以使得程序仅仅测量这一部分，这避免了遍历整个view的层级结构来计算大小。这个PieChart 例子展示了如何继承ViewGroup作为自定义view的一部分。PieChart 有子views，但是它从来不测量它们。而是根据他自身的layout法则，直接设置它们的大小。</p>
<p>具体查看<a href="http://hukai.me/android-training-course-in-chinese/ui/custom-view/optimize-view.html" target="_blank" rel="noopener">这里</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/android/" rel="tag"># android</a>
          
            <a href="/tags/2021/" rel="tag"># 2021</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/03/28/page-sync-data/" rel="next" title="安卓不同页面间同步数据">
                <i class="fa fa-chevron-left"></i> 安卓不同页面间同步数据
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/03/30/constrainLayout/" rel="prev" title="android 约束布局ConstraintLayout">
                android 约束布局ConstraintLayout <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">tzhxh</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">tzhxh</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
